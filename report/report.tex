% OWD 2023

\documentclass[10pt,a4paper,reqno]{amsart}
\usepackage{xcolor}
\usepackage[foot]{amsaddr} % Move authorship information to the front page
\usepackage{caption, subcaption, float, etoolbox} % Enhanced float environments
\usepackage{minted, realboxes} % Source code (Haskell) formatting

\usepackage[%
	backend = biber,
	sorting = none,
	bibencoding = utf8,
	style = alphabetic
]{biblatex}

\usepackage[%
	colorlinks = true,
	allcolors = blue,
        linktoc = page
]{hyperref}

\input{../catmacros.tex} % Common category-theoretic macros

% -- Begin Minted listing options for Haskell

\definecolor{codebgcol}{rgb}{0.85,0.85,0.85}
\newcommand{\inlinehask}[1]{\mintinline[bgcolor=codebgcol]{haskell}{#1}}
\newcommand{\barehask}[1]{\Colorbox{codebgcol}{#1}}
\AtBeginEnvironment{listing}{\setlength{\abovecaptionskip}{.2em}}
\newcommand{\listingautorefname}{Listing}

\setminted[haskell]{%
        frame = lines,
        framesep = 2mm,
        baselinestretch = 1.2,
        bgcolor = codebgcol,
        fontsize = \footnotesize,
        linenos
}

% -- End Minted listing options for Haskell

% \yorkemail: takes the username and outputs a clickable mailto link.
\newcommand{\yorkemail}[1]{\href{mailto:#1@york.ac.uk}{#1@york.ac.uk}}

% Make bullet points slightly smaller (they look overwhelming in a 10pt font).
\renewcommand{\labelitemi}{$\vcenter{\hbox{\tiny$\bullet$}}$}

% Add appropriately padded frames around numbered figures and sub-figures.
\numberwithin{figure}{section}
\AtBeginEnvironment{subfigure}{\vspace{2em}}
\floatstyle{boxed}
\restylefloat*{figure}

\setcounter{tocdepth}{1} % Only show major sections in the Table of Contents
\addbibresource{report.bib} % Use a universal sources file for BibLaTeX

% -- Begin document metadata setup

\title[An Investigation of Elementary Category Theory]{An Investigation of %
        Elementary Category Theory, with applications in Pure Mathematics and %
        Theoretical Computer Science}

\author{Matthew Drury} \email{\yorkemail{md1499}}
\author{Ben Brook}     \email{\yorkemail{bb1170}}
\author{Oliver Dixon}  \email{\yorkemail{od641}}

\address{Department of Mathematics \\
        University of York \\
        United Kingdom}
\date{Spring--Summer Term, 2023}

% -- End document metadata setup

\begin{document}
\begin{abstract}
        TODO
\end{abstract}
\maketitle
\tableofcontents
\section{\for{toc}{\texorpdfstring{\textbf{[MD]~}}{}}Theoretical %
        Underpinnings: Axiomatic Constructions}
\begin{flushright}
        \textbf{(Written by Matthew Drury.)}
\end{flushright}

\subsection{The idea of a Category}
A category is a mathematical structure that links a collection of objects with
non-symmetric relationships called morphisms.  Each morphism can be said to
traverse from one object to another.  They are used to create abstract models of
mathematical concepts and structures based on the role each object plays. The
objects and morphisms are extremely versatile in what they can represent as
shown in the commutative diagrams below:

\begin{equation}
        \begin{tikzcd}
                A \ar[r,"\text{Father}"] & B \ar[d,"\text{Brother}"] \\
                D & C \ar[l,"\text{Husband}"]
        \end{tikzcd}
        \begin{tikzcd}
        A
        \end{tikzcd}
        \begin{tikzcd}
        A
        \end{tikzcd}
\end{equation}
These diagrams are usually used to give a sample of a category to demonstrate
it's properties.  Mathematicians like to generalize with categories and consider
cases with infinite objects and morphisms.  The most valuable mathematical facts
tend to be those that apply to the most situations possible.  For instance,
uncovering the quadratic formula being more important than solving a
particularly difficult quadratic.  It makes all non-trivial quadratics easier to
solve and uncovers a method to determine whether the solutions are real or
complex using the ``$b^2-4ac$'' term.

Morphisms are combined together in a process called composition.  It means to do
one morphism and then another, given that the target object of the first
morphism is the same as the source of the second morphism.  Above we can see
that person $A$ has father person $B$, who has brother person $C$.  We can
compose these two together to have a morphism from $A$ to $C$ which we can could
``uncle''.  These composite morphisms are implied to exist by the diagram and
such are usually redundant to show.  This can be done as many times as one
wants, so if there is a path to traverse from any object to another, there is a
composite morphism between the two.  Hence there is a morphism from $A$ to $D$
which we could call ``uncle in-law''.

There are also identity morphisms.  These go from an object to itself and are
equivalent to not doing a morphism at all, as when they are composed with
another morphism $f$, the resulting composite morphism is equal to $f$.  The
morphism has done nothing, like how multiplying a number by 1(The multiplicative
identity) does not change it's value.  It is similar to stating that something
is equal to itself which is a trivial fact but an important feature of the
structure of categories.  It should be noted that it may not be the only
morphism from one object to itself.

The point of categories is to get more subtle notions of similarity or
``sameness''.
By creating categories we abstract things to their roles and by comparing
categories or spotting patterns and structures within them, we can see
properties shared by things that would initially seem very different.  Lines of
thought in one context can be more easily translated into another by seeing
equivalent structural features.  Mathematicians can then try new methods to
solve problems and prove new facts or describe multiple problems as one that is
more general.
\subsection{Axioms and notation}
We will now formally define a category. The following axioms are necessary for a
structure to be considered a category.
\begin{enumerate}
        \item \textbf{Objects:} In a category $C$ there is $ob(C)$, which is a
        collection of all the objects of $C$.

        \item \textbf{Morphisms:} For each pair ordered pair of objects $(A,B)$
        in a category $C$ we have $hom(A,B)$, also written as $C(A,B)$.  This is
        the collection of all morphisms from A to B, short for ``homomorphism
        set''.  Homomorphisms are those that preserve the structure of objects
        and for many useful categories they are necessary for the axioms to
        hold.  However, this property does not need to hold to use this
        notation.  A morphism $f$ is notated to map $A$ to $B$ by $f: A\to B$.

        \item \textbf{Composition:} For objects $A,B,C\in ob(C)$ if there exists
        morphisms $(f: A\to B)\in hom(A,B)$ and $(g: B\to C)\in hom(B,C)$, then
        there exists $(g\circ f: A\to C)\in hom(A,C)$

        \item \textbf{Identities:} Every object $A$ in a category $C$ has an
        identity morphism which maps from $A$ to itself.  It is notated $1_A:
        A\to A$ for $A\in ob(C), 1_A\in hom(A,A)$.  For $f\in hom(A,B), g\in
        hom(B,A)$ the identity has the property that $f\circ 1_A = f, 1_A\circ g
        = g$ Each identity is unique to it's object. If there was 2 identities
        $I_1,I_2\in A$ then $(f\circ I_1 = f = f\circ I_2) \implies I_1=I_2$

        \item \textbf{Associativity:} A morphism $h\circ(g\circ f) = (h\circ
        g)\circ f$.  This means that two morphisms are equal if they are
        composed from the same morphisms in the same order regardless of the
        order in which we compute the individual composite pairs.
\end{enumerate}

\subsection{Size of categories}
The collection $ob(C)$ and the collections $hom(A,B)$ do not have to be finite.
The idea of category size means to place categories in a hierarchy of
containment. This is to accommodate how $ob(C)$ and $hom(A,B)$ do not have to be
sets either.

When defining an infinite collection of objects by their properties, it can
create contradictions. Famously in set theory there is Russel's paradox.  It
states that if you have a set S that contains every set which doesn't contain
itself, then suppose that S does not contain S, it would imply that S is in fact
in S as it does not contain itself and vice versa.

Formally, $S = \{x\;\text{is a set}\:|\:x\notin x\}, (S\in S) \iff (S\notin S)$.

There were many examples of these paradoxes that were uncovered in the early
20th century. Mathematicians are too rigorous to allow such a thing, so to solve
the issue they devised axiomatic systems to limit the properties that members of
sets can be said to follow.  This makes some sets very convoluted to define and
means there are well defined collections of objects that cannot be put into a
set. Categories address this issue in a more elegant way.  Firstly, categories
do not claim to contain elements; the core concept is instead relationships.
Secondly, categories have a hierarchy of containment such that they only contain
categories ``smaller'' than themselves.  It follows then that categories are not
defined in a self referential manner like in Russel's paradox.

A small category is where $ob(C)$ and each $hom(A,B)$ can be described as a set.
A locally small category is where $ob(C)$ does not form a set but each
$hom(A,B)$ does.

A large category is where nether $ob(C)$ nor $hom(A,B)$ are a set. The hierarchy
means that if you wanted a category where small categories are objects, it would
have to be a large category. Then, if you wanted a category of large categories,
you would need a super-large category and so on. This can be used to formally
think about multiple layers of generalisation and abstraction.
\section{\for{toc}{\texorpdfstring{\textbf{[BB]~}}{}}Category-Theoretic %
        Interpretations of Familiar Structures}
\begin{flushright}
        \textbf{(Written by Ben Brook.)}
\end{flushright}

\noindent BB: TODO.

\section{\for{toc}{\texorpdfstring{\textbf{[OD]~}}{}}Further Applications: %
        Functional Programming and \texorpdfstring{$\lambda$}{Lambda}-Calculus}
\begin{flushright}
        \textbf{(Written by Oliver Dixon.)}
\end{flushright}

\subsection{Functional Programming and Haskell}

In purely functional languages, there is no allowance for context, or mutable
variables of any kind. Each function must accept some data, perform some strict
transformation upon the data---as defined by the algorithm---and return the
result. Whilst this robust paradigm does open a wide range of mathematical
avenues involving proof, safety, and reproducibility, the prohibition of
stateful computation renders many common tasks, such as system I/O or
communication over a network socket, largely impossible, as these imperatively
defined operations inherently contravene the purity principles of functional
programming.

Haskell is a commonly used purely functional programming language, and
suffers, as do all languages in the same class, from this blaring issue.
Indeed, early versions of Haskell did not support the chaining of stateful
computation in any sense, due to the obligatory absence of a fixed execution
order in functional paradigms; programmers were forced to resort to breaking the
purity of the language through aesthetically unpleasant techniques, ultimately
obviating the mathematical essence of the Haskell formal type system.

Due to the strength of the Haskell type system and function interface, we may
define a corresponding category, $\cathask$, within which the objects are
Haskell types, and the morphisms are functions\footnotemark.
%
\footnotetext{Due to the $\lambda$-Calculus concept of \emph{currying}, named
after Haskell Curry, functions taking multiple arguments may be decomposed into
a chain of function compositions, in which each function strictly accepts and
returns a single argument. This is made explicit in Haskell, where the type
signature of a function \inlinehask{f} may be defined as \inlinehask{f :: a -> b
-> c}, invoked as \inlinehask{f a b}, and expected to return a value of type
\barehask{c}. This function signature is trivially equivalent to the
\emph{uncurried} form of \inlinehask{f}, defined as \inlinehask{f :: (a -> b) ->
c}.}%

\subsection{Monoidal Categories and Monoids}

Before fully exploiting the structure of $\cathask$, we must develop the theory
of \emph{monoidal categories} and their corresponding \emph{monoids}. Monoidal
categories can be regarded as a six-tuple $(\arbcat{C}_0, \otimes, I, \alpha,
\lambda, \rho)$, containing various components \autocite{Kelly:1982}:
\begin{itemize}
        \item A base category, $\arbcat{C}_0$;

        \item A bifunctor $\otimes \colon \arbcat{C}_0 \times \arbcat{C}_0 \to
        \arbcat{C}_0$;

        \item An identity object $I \in \catobj \arbcat{C}_0$;

        \item An associativity natural transformation $\alpha_{A,B,C} \colon (A
        \otimes B) \otimes C \to A \otimes (B \otimes C)$;

        \item A left-identity natural transformation $\lambda_A \colon I \otimes
        A \to A$;

        \item A right-identity natural transformation $\rho_A \colon A \otimes I
        \to A$.
\end{itemize}

To maintain brevity, the natural transformations are often omitted from the
tuple-descriptions of monoidal categories: $(\arbcat{C}_0, \otimes, I)$. In this
context, the natural transformations $\alpha$, $\lambda$, and $\rho$ are used to
induce certain properties on $\otimes$, which it may not possess natively; this
can be illustrated with a pair of commutative diagrams as in
\autoref{fig:monoidal-cat-commute}.
Then, monoids can be considered as three-tuples, consisting of an object in a
monoidal category $(\arbcat{C}, \otimes, I)$, and coupled with two lifting
morphisms:
\begin{itemize}
        \item A base object $M \in \catobj \arbcat{C}$;
        \item A \emph{multiplication} morphism $\mu \in \cathom_\arbcat{C} (M
        \otimes M, M)$;
        \item A \emph{unit} morphism $\eta \in \cathom_\arbcat{C} (I, M)$.
\end{itemize}
Once more, the natural transformations from the parent monoidal category
$\arbcat{C}$ can be used to induce properties on $\mu$, as in
\autoref{fig:monoid-commute}.

\subsection{The Category of Endofunctors}

For the purposes of functional programming, and the wider formal treatment of
functional type systems, a particularly useful monoidal category concerns the
\emph{category of endofunctors} over some fixed base category $\arbcat{C}_0$.
Denoted as $\catendo{(\arbcat{C}_0)}$, this forms a monoidal category with the
associated bifunctor being the standard operation of endofunctor composition.

% \subsection{Functors in Haskell}
%
% An important construct in Haskell are \emph{functors}. Over $\cathask$,
% Haskell functors allow the mapping of types from $\cathask$ to $\cathask$, by
% some arbitrary Haskell function; morphisms are transposed similarly (see
% \autoref{lst:hask-functor}). Clearly, all functors over $\cathask$ are
% endofunctors.
%
% \begin{listing}
%         \inputminted{haskell}{haskell/Functor.hs}
%         \caption{The Haskell \texttt{Functor} type signature.}
%         \label{lst:hask-functor}
% \end{listing}

% -- Begin figure appendices.
%
% This is probably a temporary measure while the exact positioning of things is
% being calculated. Once the content is complete and the box sizes are known,
% these figures should probably be embedded into the prose rather than being
% pushed to the endmatter like this.

\clearpage
\subsection{Appendix of Monoidal Commutative Diagrams}
~
\begin{figure}[h!]
        \begin{subfigure}{\textwidth}
                \centering
                \begin{tikzcd}[ampersand replacement=\&]
                        \left[(A \otimes B) \otimes C \right] \otimes D
                                \arrow[r, "\alpha"]
                                \arrow[d, "\alpha\,\otimes\,\catid D" swap] \&
                        (A \otimes B) \otimes (C \otimes D)
                                \arrow[r, "\alpha"] \&
                        A \otimes \left[ B \otimes (C \otimes D) \right] \\
                        \left[ A \otimes (B \otimes C) \right] \otimes D
                                \arrow[rr, "\alpha" swap] \& \&
                        A \otimes \left[ (B \otimes C) \otimes D \right]
                                \arrow[u, "\catid A\,\otimes\,\alpha" swap]
                \end{tikzcd}%
                \caption{Associativity induced by $\alpha$}
        \end{subfigure}

        \begin{subfigure}{\textwidth}
                \centering
                \begin{tikzcd}[sep=large, ampersand replacement=\&]
                        (B \otimes I) \otimes C
                                \arrow[rr, "\alpha"]
                                \arrow[rd, "\rho\,\otimes\,\catid C" swap] \& \&
                        B \otimes (I \otimes C)
                                \arrow[ld, "\catid B\,\otimes\,\lambda"] \\
                        \& B \otimes C \&
                \end{tikzcd}%
                \caption{Left- and right-identities induced by $\lambda$ and
                        $\rho$}
        \end{subfigure}%
        \caption{The natural transformations invoke commutativity on the
        bifunctor $\otimes$ applied to objects $A$, $B$, $C$, $D$, and $I$.}
        \vspace{1.5em}
        \label{fig:monoidal-cat-commute}
\end{figure}

\begin{figure}[h!]
        \begin{subfigure}{\textwidth}
                \centering
                \begin{tikzcd}[sep=large, ampersand replacement=\&]
                        (M \otimes M) \otimes M
                                \arrow[r, "\alpha"]
                                \arrow[d, "\mu\,\otimes\,\catid M" swap] \&
                        M \otimes (M \otimes M)
                                \arrow[r, "\catid M\,\otimes\,\mu"] \&
                        M \otimes M
                                \arrow[d, "\mu"] \\
                        M \otimes M
                                \arrow[rr, "\mu" swap] \& \& M
                \end{tikzcd}%
                \caption{Associativity on $\mu$ induced by $\alpha$}
        \end{subfigure}

        \begin{subfigure}{\textwidth}
                \centering
                \begin{tikzcd}[sep=large, ampersand replacement=\&]
                        I \otimes M
                                \arrow[r, "\eta\,\otimes\,\catid M"]
                                \arrow[rd, "\lambda" swap] \&
                        M \otimes M
                                \arrow[d, "\mu" swap] \&
                        M \otimes I
                                \arrow[l, "\catid M\,\otimes\,\eta" swap]
                                \arrow[ld, "\rho"] \\
                        \& M \&
                \end{tikzcd}%
                \caption{Left- and right-identities of $M$ induced by $\lambda$
                        and $\rho$}
        \end{subfigure}%
        \caption{The natural transformations also apply within the monoid.}
        \vspace{1.5em}
        \label{fig:monoid-commute}
\end{figure}

% -- End figure appendices.

\clearpage
\addtocontents{toc}{\protect\vspace{5pt}}
\printbibliography[title=Cited Works]
\end{document}

